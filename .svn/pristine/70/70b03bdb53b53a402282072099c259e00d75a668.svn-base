package com.doteyplay.game.service.runtimecache;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.mina.core.session.IoSession;

import com.doteyplay.core.bhns.BOServiceManager;
import com.doteyplay.core.bhns.gateway.IGateWayService;
import com.doteyplay.core.server.task.TaskCallbackHandler;
import com.doteyplay.core.service.CoreServiceConstants;
import com.doteyplay.game.domain.session.SessionHolder;
import com.doteyplay.game.service.bo.gateway.ACKTask;
import com.doteyplay.game.service.bo.virtualworld.IVirtualWorldService;
import com.doteyplay.game.task.TaskManager;
import com.doteyplay.net.message.AbstractMessage;
import com.doteyplay.net.protocol.DefaultSessionHandler;

import common.Logger;

public class GlobalSessionCache
{
	private static final Logger logger = Logger
			.getLogger(GlobalSessionCache.class);

	private GlobalSessionCache()
	{
		// Thread t = new Thread(new Runnable()
		// {
		// @Override
		// public void run()
		// {
		// while(true)
		// {
		// try
		// {
		// Thread.sleep(2000);
		// } catch (InterruptedException e)
		// {
		// e.printStackTrace();
		// }
		// System.out.println("size====="+uIdCache.size()+","+sessionCache.size()+","+rIdCache.size()
		// +","+sessionIdCache.size());
		// Runtime rt = Runtime.getRuntime();
		// long totalMemorySize = rt.totalMemory(); //初始的总内存
		// long maxMemorySize = rt.maxMemory(); //最大可用内存
		// long freeMemorySize = rt.freeMemory(); //当前可用内存
		//
		// System.out.println("totalMemorySize = "+totalMemorySize);
		// System.out.println("maxMemorySize = " + maxMemorySize);
		// System.out.println("freeMemorySize = "+freeMemorySize);
		// }
		// }
		// });
		// t.start();
	}

	// userId
	private Map<Long, SessionHolder> uIdCache = new ConcurrentHashMap<Long, SessionHolder>();
	// session
	private Map<IoSession, SessionHolder> sessionCache = new ConcurrentHashMap<IoSession, SessionHolder>();
	// roleId
	private Map<Long, SessionHolder> rIdCache = new ConcurrentHashMap<Long, SessionHolder>();
	// sessionId;
	private Map<Long, IoSession> sessionIdCache = new ConcurrentHashMap<Long, IoSession>();

	public void add(long userId, IoSession session, long roleId)
	{
		SessionHolder holder = new SessionHolder();
		holder.setSession(session);
		holder.setUserId(userId);
		holder.setHasAuth(true);
		holder.setCurRoleId(roleId);
		holder.setSessionId(getSessionIdByGatewayEndpoint(session));

		uIdCache.put(userId, holder);
		sessionCache.put(session, holder);
		rIdCache.put(roleId, holder);

		TaskCallbackHandler callbackHandler = TaskManager
				.getInstance()
				.getUserTaskService()
				.scheduleAtFixedRate(new ACKTask(holder), 2000L,
						CoreServiceConstants.MILLISECOND_PER_FRAME);
		holder.setCallbackHandler(callbackHandler);
	}

	public void addSession(IoSession session)
	{
		long sessionId = GlobalSessionCache
				.getSessionIdByGatewayEndpoint(session);
		if (sessionIdCache.get(sessionId) == null)
			sessionIdCache.put(sessionId, session);
	}

	public IoSession getSessionBySessionId(long sessionId)
	{
		return sessionIdCache.get(sessionId);
	}

	public void disconnect(IoSession session)
	{
		SessionHolder holder = sessionCache.get(session);
		if (holder != null)
		{
			this.disconnect(holder.getUserId());
		} else
		{
			sessionIdCache.remove(getSessionIdByGatewayEndpoint(session));
			session.close(true);
		}
	}

	public void disconnect(long userId)
	{
		SessionHolder holder = uIdCache.remove(userId);
		if (holder != null && holder.getSession() != null)
		{
			holder.getSession().close(false);
			sessionCache.remove(holder.getSession());
			sessionIdCache.remove(getSessionIdByGatewayEndpoint(holder
					.getSession()));

			if (holder.getCurRoleId() > 0)
			{
				rIdCache.remove(holder.getCurRoleId());

				IVirtualWorldService virtualWorldService = BOServiceManager
						.findDefaultService(IVirtualWorldService.PORTAL_ID);
				virtualWorldService.doLogout(holder.getCurRoleId());
			}
		} else
		{
			logger.error("下线内存泄露！！！！！！！！！！！！！！！！！！");
		}
	}

	public void disconnectAll()
	{
		for (IoSession session : sessionCache.keySet())
		{
			this.disconnect(session);
		}
	}

	public SessionHolder getByUserId(long userId)
	{
		return uIdCache.get(userId);
	}

	public SessionHolder getByRoleId(long roleId)
	{
		return rIdCache.get(roleId);
	}

	public SessionHolder getBySession(IoSession session)
	{
		if (session != null)
			return sessionCache.get(session);
		return null;
	}

	public int getUserCount()
	{
		return uIdCache.size();
	}

	public int getSessionCount()
	{
		return sessionIdCache.size();
	}

	public void sendMessageBySessionId(AbstractMessage message, long sessionId)
	{
		IoSession session = this.getSessionBySessionId(sessionId);
		SessionHolder.sendMsg(message, session);
	}

	public void sendMessageByRoleId(AbstractMessage message, long roleId)
	{
		SessionHolder holder = this.getByRoleId(roleId);
		if (holder != null)
			holder.sendMsg(message);
	}

	// //////////////////////////////////////////////////////////////////
	private static GlobalSessionCache instance = new GlobalSessionCache();

	public static GlobalSessionCache getInstance()
	{
		return instance;
	}

	public static long getSessionIdByGatewayEndpoint(IoSession session)
	{
		// 前8位为网关服务器节点
		long sessionId = ((session.getId() << 8) >>> 8)
				| (long) BOServiceManager
						.findLocalEndpointId(IGateWayService.PORTAL_ID) << 56;
		return sessionId;
	}

}
