//
//  FightMgr.cpp
//  fancyHeart
//
//  Created by 秦亮亮 on 14-5-15.
//
//

#include "FightMgr.h"

static FightMgr* instance=nullptr;

FightMgr* FightMgr::getInstance(){
    if(instance==nullptr){
        instance=new FightMgr();
    }
    return instance;
}

void FightMgr::init(std::vector<long>heros,int nodeID,int gateID)
{
    auto scene=FightScene::createScene();
    Manager::getInstance()->switchScence(scene);

    this->gateID=gateID;
    this->nodeID=nodeID;
    this->view=(FightScene*)scene->getChildByTag(0);
   
    XNode* xn=XNode::record(Value(nodeID));
    
    int battleID=xn->getBattleID();
    XBattle* xb=XBattle::record(Value(battleID));
    if(xb->getMGroup1()>0){
        this->groups.push_back(xb->getMGroup1());
    }
    if(xb->getMGroup2()>0){
        this->groups.push_back(xb->getMGroup2());
    }
    if(xb->getMGroup3()>0){
        this->groups.push_back(xb->getMGroup3());
    }
    if(xb->getMGroup4()>0){
        this->groups.push_back(xb->getMGroup4());
    }
    if(xb->getMGroup5()>0){
        this->groups.push_back(xb->getMGroup5());
    }
    this->npcNum=this->groups.size();
    this->view->setNpcIcon(this->npcNum,false);
    
    this->initHero(heros);
    this->initSkill();

    this->groupID=this->groups.at(0);
    this->groups.erase(groups.begin());

    DramaAni::getInstance()->startPre(this->groupID,this->gateID,this->nodeID);
}

void FightMgr::init(rapidjson::Value& data)
{
    
}

void FightMgr::startBattle()
{
    this->isOver=false;
    this->view->bg->setDisplayFrame(Sprite::create("fightBg2.png")->displayFrame());
    

    this->view->bg->runAction(Sequence::create(FadeOut::create(1),FadeIn::create(1), NULL));
    
    FightMgr::getInstance()->npcs.clear();
    this->groupID=this->groups.at(0);
    this->groups.erase(groups.begin());
    this->initNpc();
    
    //hero
    Size winSize=Director::getInstance()->getWinSize();
    for(int i=0;i<this->heros.size();i++){
        NpcMgr* mf=heros.at(i);
        int pos=mf->pos;
        mf->view->setPosition(Vec2(-GRID_SIZE*3*i,winSize.height/2+(pos%2?-GRID_SIZE:GRID_SIZE)));
        this->view->heroNode->reorderChild(mf->view, 640-abs(mf->view->getPositionY()));
        mf->view->state=fstate::idle;
        mf->start();
    }
}

void FightMgr::initHero(std::vector<long> hero)
{
    //初始化角色100
    std::vector<int> ids={100,101,101,102,999};
    std::vector<BData> heros;
    for(int i=0;i<ids.size();i++){
        heros.push_back(BData{ids.at(i),1,1,1,i});
    }
    Size winSize=Director::getInstance()->getWinSize();
    sort(heros.begin(),heros.end(), FightMgr::sortGrid);

    Vector<FData*> arr;
    for(int i=0;i<heros.size();i++)
    {
        BData bd=heros.at(i);
        if(bd.xid==999 || bd.xid==998){
//            bd.lv=9;
            bd.rate=9;
        }
        FData* fd=FData::create(bd);
        NpcMgr* hero=NpcMgr::create(fd);
        this->heros.pushBack(hero);
    }
}

void FightMgr::initNpc()
{
//    int groupID=this->groups.at(0);
//    this->groups.erase(groups.begin());
    this->view->resetProgress();

    std::vector<BData> npc;
    XMonster* xm=XMonster::record(Value(this->groupID));
    
    int mid=xm->getMID1();
    npc.push_back({mid/10,xm->getMLv1(),mid%10,xm->getMStar1(),5});
    
    mid=xm->getMID2();
    if(mid > 0){
        npc.push_back({mid/10,xm->getMLv2(),mid%10,xm->getMStar2(),6});
    }
    
    mid=xm->getMID3();
    if(mid > 0){
        npc.push_back({mid/10,xm->getMLv3(),mid%10,xm->getMStar3(),7});
    }
    
    mid=xm->getMID4();
    if(mid > 0){
        npc.push_back({mid/10,xm->getMLv4(),mid%10,xm->getMStar4(),8});
    }
    
    mid=xm->getMID5();
    if(mid > 0){
        npc.push_back({mid/10,xm->getMLv5(),mid%10,xm->getMStar5(),9});
    }
    
    //init modle & view
    Size winSize=Director::getInstance()->getWinSize();
    sort(npc.begin(), npc.end(), this->sortGrid);
    
    for(int i=0;i<npc.size();i++)
    {
        FData* fd=FData::create(npc.at(i));
        NpcMgr* npc=NpcMgr::create(fd);
        this->npcs.pushBack(npc);
        npc->start();
    }
}

void FightMgr::initSkill()
{
    std::vector<int> skills={15201,15301,15401,15501,15601};
    //普通攻击特殊处理
    for(int i=0;i<skills.size();i++){
        this->view->skillIcons.at(i)->setTag(skills.at(i));
        this->view->skillIcons.at(i)->setVisible(true);
    }
    
}

void FightMgr::skillAttack(int skill)
{
    SpriteFrameCache::getInstance()->addSpriteFramesWithFile("effect/ziguang.plist");

    for(NpcMgr* mf : this->npcs){
//        mf->fallHp(20);
//        mf->view->fallHp(Value(20));
    }
    Clip* clip=Clip::create("effect/ziguang.plist","ziguang.png", 12);
    this->view->addChild(clip,1);
    clip->setPosition(npcs.at(0)->view->getPosition());
    clip->play();
    
    roleMp-=XSkill::record(Value(-skill))->getMp()*BEAN_NUM;
}

bool FightMgr::sortGrid(BData f1,BData f2)
{
    int dis1=XRole::record(Value(f1.xid))->getLockGrid();
    int dis2=XRole::record(Value(f2.xid))->getLockGrid();
    return dis1-dis2<0;
}

std::vector<int> FightMgr::getFoes(int pos,bool isMe)
{
    std::vector<int> arr;
    if((pos<5 && isMe) || (pos>4 && !isMe)){
        for(NpcMgr* mf : heros){
            if(mf->view->state==fstate::die || mf->view->state==fstate::over) continue;
            arr.push_back(mf->pos);
        }
    }
    if((pos<5 && !isMe) || (pos>4 && isMe)){
        for(NpcMgr* mf : npcs){
            if(mf->view->state==fstate::die || mf->view->state==fstate::over) continue;
            arr.push_back(mf->pos);
        }
    }
    return arr;
}

NpcMgr* FightMgr::getFirst(int pos)
{
    NpcMgr* pRet=nullptr;
    if(pos > 4){
        pRet=heros.at(0);
        for(NpcMgr* mf : heros){
            if(mf->view->getPositionX() > pRet->view->getPositionX()){
                pRet=mf;
            }
        }
    }else{
        pRet=npcs.at(0);
        for(NpcMgr* mf :npcs){
            if(mf->view->getPositionX() < pRet->view->getPositionX()){
                pRet=mf;
            }
        }
    }
    return pRet;
}

MFighter* FightMgr::getRole()
{
    if(this->heros.size()<2){
        return nullptr;
    }
//    for(auto mf : this->heros){
//        if(mf && mf->getIsRole()){
//            return mf;
//        }
//    }
    return nullptr;
}

NpcMgr* FightMgr::getHero(int pos){
    if(pos<5){
        for(NpcMgr* mf : heros){
            if(mf->pos==pos){
                return mf;
            }
        }
    }else{
        for(NpcMgr* mf : npcs){
            if(mf->pos==pos){
                return mf;
            }
        }
    }
    return nullptr;
}

void FightMgr::stopAllFighter()
{
    for(NpcMgr* npc :heros){
        npc->pause();
        if(npc->view->state!=fstate::die){
            npc->view->state=fstate::over;
        }
    }
    for(NpcMgr* npc : npcs){
        npc->pause();
        if(npc->view->state!=fstate::die){
            npc->view->state=fstate::over;
        }
    }
}

void FightMgr::startEndDram()
{
    this->isOver=true;

    for(NpcMgr* mf : heros) {
        mf->view->setVisible(false);
        mf->pause();
    }
    DramaAni::getInstance()->startEnd(this->groupID,this->gateID,this->nodeID);
}

void FightMgr::handleResult()
{
    if(this->winPos<5 && this->groups.size()){
        for(NpcMgr* mf : FightMgr::getInstance()->heros){
            if(mf->view->state==fstate::die){
                continue;
            }
            mf->view->setVisible(true);
            mf->view->run();
        }
        Director::getInstance()->getScheduler()->schedule(SEL_SCHEDULE(&FightMgr::startBattle), this, 5, 0, 5, false);
        this->view->setNpcIcon(npcNum-this->groups.size(),true);
    }
    
    if(this->winPos>4 || this->groups.size()==0){
        PResultReq pResultReq;
        pResultReq.set_gateid(this->gateID);
        pResultReq.set_xid(this->nodeID);
        pResultReq.set_star(3);
        Manager::getInstance()->socket->send(C_FIGHTRESULT, &pResultReq);
    }
}

void FightMgr::clearDieNpc(int pos)
{
    NpcMgr* fm=this->getHero(pos);
    if(pos<5 && pos>-1){
        this->heros.eraseObject(fm);
    }else if(pos>4 && pos<10){
        this->npcs.eraseObject(fm);
    }else{
        log("die error pos:%d",pos);
    }
}

void FightMgr::clear()
{
    this->heros.clear();
    this->npcs.clear();
    this->groups.clear();
}