package com.doteyplay.luna.client.container;

import java.net.InetSocketAddress;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.log4j.Logger;
import org.apache.mina.core.future.ConnectFuture;
import org.apache.mina.core.session.IoSession;
import org.apache.mina.transport.socket.SocketConnector;

import com.doteyplay.luna.client.ConnectionInfo;
import com.doteyplay.luna.common.message.DecoderMessage;
import com.doteyplay.luna.common.message.EncoderMessage;
import com.doteyplay.luna.util.SynKeyUtil;

public class SynchronicConnection
{
	
	private static final Logger logger = Logger.getLogger(SynchronicConnection.class);
	
	private IoSession session;
	private ReentrantLock lock;
	public SocketConnector connector;
	private long maxTimeOut;
	private ConnectionInfo connectionInfo;

	private Map<Long, DecoderMessage> resultMap = new ConcurrentHashMap<Long, DecoderMessage>();

	public SynchronicConnection(ConnectionInfo connect)
	{
		lock = new ReentrantLock();
		connectionInfo = connect;
		maxTimeOut = connect.getMaxTimeOut();
	}

	public SynchronicConnection(IoSession session)
	{
		lock = new ReentrantLock();
		this.session = session;
	}

	public boolean connect()
	{
		ConnectFuture connectFuture = connector.connect(new InetSocketAddress(
				connectionInfo.getServerAddress(), connectionInfo
						.getServerPort()));
		connectFuture.awaitUninterruptibly(connectionInfo.getConnectTime());
		try
		{
			session = connectFuture.getSession();
		} catch (Exception e)
		{
			e.printStackTrace();
			return false;
		}
		
		if(session == null || !session.isConnected())
			return false;
		
		return true;
	}

	public void asynInvoke(EncoderMessage message)
	{
		try
		{
			session.write(message);
		} catch (Exception e)
		{
			e.printStackTrace();
			logger.error("目标服务发送异步请求失败,connectionInfo:"+connectionInfo, e);
		}
	}

	public DecoderMessage synInvoke(EncoderMessage message)
	{
		DecoderMessage result;
		try
		{
			long synKey = SynKeyUtil.getSynkey();
			message.setSynKey(synKey);
			
			session.write(message);
			int temp = 0;
			do
			{
				result = resultMap.remove(synKey);
				if (temp >= maxTimeOut || result != null)
					break;
				temp += 100;
				synchronized (lock)
				{
					lock.wait(100L);
				}
			} while (true);

			return result;
		} catch (Exception e)
		{
			e.printStackTrace();
			logger.error("目标服务发送同步请求失败,connectionInfo:"+connectionInfo, e);
		}
		throw new RuntimeException("目标服务没有返回远程调用结果");
	}

	public void release(DecoderMessage rb)
	{
		resultMap.put(rb.getSynKey(), rb);
		synchronized (lock)
		{
			lock.notify();
		}
	}

	public void close()
	{
		session.close(true);
	}
}
